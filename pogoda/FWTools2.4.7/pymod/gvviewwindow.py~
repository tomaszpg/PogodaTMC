#!/usr/bin/env python
###############################################################################
# $Id: gvviewwindow.py,v 1.46 2001/07/06 17:05:09 warmerda Exp $
#
# Project:  OpenEV
# Purpose:  OpenEV General Purpose GvViewWindow class.
# Author:   Frank Warmerdam, warmerda@home.com
#
###############################################################################
# Copyright (c) 2000, Atlantis Scientific Inc. (www.atlsci.com)
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
###############################################################################
# 
#  $Log: gvviewwindow.py,v $
#  Revision 1.46  2001/07/06 17:05:09  warmerda
#  added rawgeo icon
#
#  Revision 1.45  2001/06/27 14:32:56  warmerda
#  added subdataset selection support
#
#  Revision 1.44  2001/05/15 14:15:07  warmerda
#  changed to use gvutils.is_shapefile
#
#  Revision 1.43  2001/05/15 14:04:25  warmerda
#  Open shapefile based on .shp, .shx or .dbf.
#
#  Revision 1.42  2001/05/04 20:37:44  warmerda
#  select wildcarded files, remember current directory
#
#  Revision 1.41  2001/04/09 18:36:44  warmerda
#  use oeattedit.launch()
#
#  Revision 1.40  2001/03/21 05:51:29  warmerda
#  added legend and classify dialog support
#
#  Revision 1.39  2001/03/19 21:57:14  warmerda
#  expand tabs
#
#  Revision 1.38  2001/01/15 20:46:53  warmerda
#  Added support for the view_background_color preference.  Note there
#  is currently no gui way of setting it.
#
#  Revision 1.37  2001/01/15 17:16:04  warmerda
#  Make X/Y entry boxes for goto panel allow more characters precision.
#

import gtk
from gtk import FALSE, TRUE
from GDK import *
import gtkmissing
import sys
import GtkExtra
import gview
import gvconst
import layerdlg
import gdal
import gvutils
import os
import pgufilesel
import pguprogress
import openev
import math
import gvhtml
import string
import glob

ratio_list = ['250:1', '200:1', '150:1', '100:1', '80:1', '60:1', '45:1',
              '35:1', '25:1', '18:1', '10:1', '8:1', '4:1', '2:1', '1:1',
              '1:2', '1:4', '1:6', '1:8', '1:10', '1:12', '1:14','1:16',
              '1:20', '1:25', '1:30', '1:40', '1:60', '1:80', '1:100',]

class GvViewWindow(gtk.GtkWindow):
    next_viewnum = 1

    def __init__(self, app=None, title=None, show_menu=1, show_icons=1, 
                 show_tracker=1, show_scrollbars=1 ):
        
        gtk.GtkWindow.__init__(self)

        if title is None:
            title = 'View %d' % GvViewWindow.next_viewnum
            GvViewWindow.next_viewnum = GvViewWindow.next_viewnum + 1

        self.app = app
        self.set_title('OpenEV: '+title)
        gvhtml.set_help_topic(self, 'mainwindow.html')
        self.title = title
        self.file_sel = None
        self.drape_file_sel = None
        self.DEM_file_sel = None
        shell = gtk.GtkVBox(spacing=0)
        self.add(shell)
        self.pref_dialog = None
        self.position3D_dialog = None
        self.set_policy(TRUE,TRUE,FALSE)
        self.zoom = 0.0
        self.zoom_flag = 'yes' # see set_zoom_factor_cb()

        # Menu bar
        if show_menu > 0:
            menuf = GtkExtra.MenuFactory()
            self.menuf = menuf
            menuf.add_entries([
                ('File/Import', None, self.file_import_cb ),
                ('File/Open', '<control>O', self.file_open_cb ),
                ('File/Open 3D', None, self.open_3D_request),
                ('File/Save Vector Layer', None, self.save_vector_layer_request),
                ('File/New View', None, self.menu_new_view),
                ('File/Print', None, self.print_cb),
                ('File/<separator>', None, None),
                ('File/rfl1', None, self.rfl_cb, 1),
                ('File/rfl2', None, self.rfl_cb, 2),
                ('File/rfl3', None, self.rfl_cb, 3),
                ('File/rfl4', None, self.rfl_cb, 4),
                ('File/rfl5', None, self.rfl_cb, 5),
                ('File/<separator>', None, None),
                ('File/Close', None, self.close),
                ('File/Exit', '<control>Q', self.exit),
                ('Edit/Undo', None, self.undo),
                ('Edit/Layers...', None, self.app.show_layerdlg),
                ('Edit/Vector Layer Attributes...', None, self.show_oeattedit),
                ('Edit/Edit Toolbar...', None, self.app.show_toolbardlg),
                ('Edit/Go To...', None, self.goto_dlg),
                ('Edit/Python Shell...', None, self.pyshell),
                ('Edit/3D Position...', None, self.position_3d),
                ('Edit/Preferences...', None, self.app.launch_preferences),
                ('Help/Help...', None, self.helpcb, 'openevmain.html'),
                ('Help/<separator>', None, None),
                ('Help/Web Page...', None, self.helpcb,
                                        'http://OpenEV.Sourceforge.net/'),
                ('Help/About...', None, self.aboutcb)
                ])
            self.add_accel_group(menuf.accelerator)

            shell.pack_start(menuf, expand=FALSE)
            self.app.subscribe('rfl-change',self.show_rfl)

        if show_icons > 0:
            self.create_iconbar()
            shell.pack_start(self.iconbar,expand=FALSE)
        
        # Add the actual GvViewArea for drawing in
        self.viewarea = gview.GvViewArea()

        if gview.get_preference('view_background_color') is not None:
            tokens= string.split(gview.get_preference('view_background_color'))
            self.viewarea.set_background_color( [ float(tokens[0]),
                                                  float(tokens[1]),
                                                  float(tokens[2]),
                                                  float(tokens[3])] )

        # Update Zoom ratio box in toolbar whenever view changes (actually, only when zoom changes)
        self.view_state_changed_id = self.viewarea.connect("view-state-changed", self.update_zoom_cb)
        
        if show_scrollbars:
            self.scrolled_window = gtk.GtkScrolledWindow()
            self.set_usize(512, 512)
            self.scrolled_window.add(self.viewarea)
            shell.pack_start(self.scrolled_window, expand=TRUE)
        else:
            self.viewarea.size(512, 512)
            self.scrolled_window = None
            shell.pack_start(self.viewarea, expand=TRUE)

        if show_tracker:
            statusbar = gtk.GtkHBox()
            shell.pack_start(statusbar, expand=FALSE)
            label = gtk.GtkLabel()
            statusbar.pack_start(label, expand=FALSE, padding=3)
            tracker = gview.GvTrackTool(label)
            tracker.activate(self.viewarea)
            self.tracker = tracker
        else:
            self.tracker = None

        # End of widgets
        self.viewarea.grab_focus()
        shell.show_all()
        self.show_rfl()

        self.app.view_manager.add_view( self )

        self.rawgeo_update()
        
        self.viewarea.connect('key-press-event', self.key_press_cb)
        
        # Trap window close event
        self.connect('delete-event', self.close)

    def show_rfl(self, *args):
        list = self.app.get_rfl()
        for i in range(5):
            menuitem = self.menuf.find('File/rfl'+str(i+1))
            if i < len(list):
                menuitem.children()[0].set_text(list[i])
                menuitem.show()
            else:
                menuitem.children()[0].set_text('')
                menuitem.hide()

    def rfl_cb(self, menuitem, rfl_index, *args):
        self.file_open_by_name(menuitem.children()[0].get(), sds_check=0)
    
    def make_active(self, *args):
        self.app.view_manager.set_active_view( self )

    def key_press_cb( self, viewarea, event, *args ):
        if event.keyval == F9:
            gview.texture_cache_dump()

    def busy_changed_cb(self,*args):
        if gview.manager.get_busy():
            self.idlebusy_pixmap.set( self.busy_icon[0], self.busy_icon[1] )
        else:
            self.idlebusy_pixmap.set( self.idle_icon[0], self.idle_icon[1] )

    def print_cb(self, *args):
        import gvprint
        pd = gvprint.GvPrintDialog( self.viewarea )
        
    def helpcb(self, item, topic='openevmain.html'):
        gvhtml.LaunchHTML( topic )

    def aboutcb(self, *args):
        window = gtk.GtkWindow()
        window.set_title('About OpenEV')
        vbox = gtk.GtkVBox(homogeneous=FALSE,spacing=15)
        window.add(vbox)

        vbox.pack_start(gtk.GtkPixmap(self, os.path.join(gview.home_dir,'pics',
                                                         'openev.xpm')))
        
        # Contributors
        contrib = gtk.GtkVBox(homogeneous=FALSE,spacing=3)
        contrib.pack_start(gtk.GtkLabel('Contributors:'))
        contrib.pack_start(gtk.GtkLabel('Frank Warmerdam (warmerda@home.com),'))
        contrib.pack_start(gtk.GtkLabel('Steve Rawlinson (srawlin@atlsci.com),'))
        contrib.pack_start(gtk.GtkLabel('Peter Farris-Manning (peter@atlsci.com),'))
        contrib.pack_start(gtk.GtkLabel('Steve Taylor,'))
        contrib.pack_start(gtk.GtkLabel('Paul Lahaie,'))
        contrib.pack_start(gtk.GtkLabel('and others'))
        vbox.pack_start(contrib)

        # Funded By
        funding = gtk.GtkVBox(homogeneous=FALSE,spacing=3)
        funding.pack_start(gtk.GtkLabel('Funding provided by:'))
        funding.pack_start(gtk.GtkPixmap(self,
           os.path.join(gview.home_dir, 'pics', 'atlantis_logo.xpm')))
        funding.pack_start(gtk.GtkLabel('Atlantis Scientific Inc.'))
        funding.pack_start(gtk.GtkPixmap(self,
                  os.path.join(gview.home_dir,'pics','geo_innovation.xpm')))
        funding.pack_start(gtk.GtkLabel('GeoInnovations'))
        vbox.pack_start(funding)

        # Other Info
        vbox.pack_start(gtk.GtkLabel('Web Site:  http://OpenEV.sourceforge.net'))
        vbox.pack_start(gtk.GtkLabel('(C) Copyright 2000 Atlantis Scientific Inc.  www.atlsci.com'))
        
        window.show_all()
        
    def close(self, *args):
        # what else do we need to do?
        if len(self.app.view_manager.get_views()) == 1:
            if self.app.request_quit() > 0:
                if self.menuf is not None:
                    self.app.unsubscribe('rfl-change',self.show_rfl)
                self.destroy()
                return FALSE
            else:
                return TRUE
        else:
            if self.menuf is not None:
                self.app.unsubscribe('rfl-change',self.show_rfl)
            self.destroy()
            return TRUE

    def exit(self, *args ):
        # should ask for confirmation at this point.
        self.app.request_quit()

    def undo(self, *args):
        self.make_active()
        gview.undo_pop()

    def show_oeattedit(self, *args):
        self.make_active()
        
        import oeattedit

        oeattedit.launch()
        
    def show_layerdlg(self, *args):
        self.layerdlg.show()
        self.layerdlg.get_window()._raise()

    def show_toolbardlg(self, *args):
        self.make_active()
        self.toolbar.show()
        self.toolbar.get_window()._raise()

    def goto_dlg(self, *args):
        """ Create the GoTo Dialog box with coordinate system option menu and
        text entry fields """
        window = gtk.GtkWindow()
        window.set_title('Go To...')
        window.set_border_width(10)
        vbox = gtk.GtkVBox(homogeneous=FALSE,spacing=15)
        window.add(vbox)

        # Make this a selection menu - doesn't work, yet!
        box = gtk.GtkHBox(spacing=3)
        vbox.pack_start(box, expand=gtk.FALSE)
        box.pack_start(gtk.GtkLabel('Coordinate System:'),expand=FALSE)
        self.coord_system_om = gvutils.GvOptionMenu(('Row/Col','Native'),
                                                    self.set_coord_system)
        box.pack_start(self.coord_system_om,expand=FALSE)
        
        # Get current position in view native projection
        #   - changing Option Menu updates this in entry fields

        current_pos = self.viewarea.get_translation()
        
        # X Position
        box = gtk.GtkHBox(spacing=3)
        vbox.pack_start(box, expand=gtk.FALSE)
        box.pack_start(gtk.GtkLabel('X Position:'),expand=FALSE)
        x_pos_entry = gtk.GtkEntry(maxlen=14)
        x_pos_entry.set_text(str(-current_pos[0]))
        box.pack_start(x_pos_entry,expand=FALSE)

        # Y Position
        box = gtk.GtkHBox(spacing=3)
        vbox.pack_start(box, expand=gtk.FALSE)
        box.pack_start(gtk.GtkLabel('Y Position:'),expand=FALSE)
        y_pos_entry = gtk.GtkEntry(maxlen=14)
        y_pos_entry.set_text(str(-current_pos[1]))
        box.pack_start(y_pos_entry,expand=FALSE)

        # Button to move
        goto_button = gtk.GtkButton('Go To...')
        goto_button.connect('clicked', self.goto_location )
        vbox.pack_start(goto_button,expand=FALSE)

        self.x_pos_entry = x_pos_entry
        self.y_pos_entry = y_pos_entry

        # set default to be native system - must be after x/y_pos_entry are setup
        self.coord_system_om.set_history(1)
        
        window.show_all()

    def set_coord_system(self, om, *args):
        """ Set coordinate system goto coordinates entered in GoTo dialog from
        option menu. """
        current_pos = self.viewarea.get_translation()
        
        if om.get_history() == 0:
            self.goto_coord_system = 'pixel'
        # Lat/Long Not Working Yet!
        elif om.get_history() == 9:
            self.goto_coord_system = 'lat-long'
        elif  om.get_history() == 1:
            self.goto_coord_system = 'native'
        else:
            self.goto_coord_system = 'native'

    def goto_location(self, Button, *args):
        """ Translate view to location specified in GoTo Dialog, using projection """
        self.make_active()

        coord_system = self.goto_coord_system
        str_x = self.x_pos_entry.get_text()
        str_y = self.y_pos_entry.get_text()

        x = string.atof(str_x)
        y = string.atof(str_y)

        if coord_system == 'pixel':
            # Get current raster
            layer = self.viewarea.active_layer()

            if (layer is None) or (gvutils.is_of_class( layer.__class__, 'GvRasterLayer' ) == 0):
                gvutils.warning('Please select a raster layer using the layer dialog.\n')
                return

            raster = layer.get_parent()
            if raster is not None:
                position = raster.pixel_to_georef(x,y)
            else:
                return
            
        # Doesn't work Yet!
        elif coord_system == 'lat-long':
            position = self.viewarea.map_location((x,y))

        elif coord_system == 'native':
            # native - do nothing
            position = (x,y)

        else:
            print 'Error in gvviewwindow.py function goto_location() passed invalid coordinate system'
            # native - do nothing
            position = (x,y)

        self.viewarea.set_translation(-position[0],-position[1])

    def menu_new_view(self, *args):
        self.app.new_view()

    def save_vector_layer_request( self, *args ):
        self.make_active()

        layer = self.viewarea.active_layer()
        if layer is None or \
           gvutils.is_of_class( layer.__class__, 'GvShapesLayer' ) == 0:
            gvutils.warning('Please select a vector layer using the layer\n'+\
                            'dialog before attempting to save.' )
            return

        pgufilesel.SimpleFileSelect( self.save_vector_layer_with_file,
                                     cb_data = layer.get_parent(),
                                     title = 'Shapefile To Save to',
                                     default_filename = layer.get_name() )

    def save_vector_layer_with_file( self, filename, shapes_data ):
        if shapes_data.save_to( filename ) == 0:
            gvutils.error('Unable to save vectors to:'+filename)

    def destroy_preferences(self,*args):
        self.pref_dialog = None
        
    def file_open_shape_by_name(self, filename):
        self.make_active()
        shape_data = gview.GvShapes(shapefilename=filename)
        if shape_data is None or shape_data._o is None:
            gvutils.error('Unable to open '+filename+' for loading.')
            return
        
        self.app.add_to_rfl(filename)
        gview.undo_register(shape_data)
        
        layer = gview.GvShapesLayer( shape_data )
        self.viewarea.add_layer(layer)
        self.viewarea.set_active_layer(layer)

    def file_open_ogr_by_name(self, filename):
        import _gv

        self.make_active()
        
        raw_data = _gv.gv_shapes_from_ogr(filename, 0)
        if raw_data is None:
            return FALSE

        self.app.add_to_rfl(filename)
        index = 0
        while raw_data is not None:
            shape_data = gview.GvShapes(_obj=raw_data)
            if shape_data is None:
                return

            if len(shape_data) > 0:
                gview.undo_register(shape_data)
        
                layer = gview.GvShapesLayer( shape_data )
                self.viewarea.add_layer(layer)
                self.viewarea.set_active_layer(layer)
            else:
                # I am not sure how to blow away the GvShapes properly.
                pass
                
            index = index + 1
            raw_data = _gv.gv_shapes_from_ogr(filename, index)

        return TRUE

    def file_import_cb(self, *args):
        self.make_active()
        pgufilesel.SimpleFileSelect( self.file_import_by_name, None,
                                     'File To Import',
                                     help_topic = 'files.html' )

    def file_import_by_name( self, filename, *args ):
        self.make_active()
        dataset = gdal.Open( filename )
        if dataset is None:
            gvutils.error('Unable to open '+filename+' for import.')
            return

        geotiff = gdal.GetDriverByName("GTiff")
        if geotiff is None:
            gvutils.error("Yikes!  Can't find GeoTIFF driver!")
            return

        newbase, ext = os.path.splitext(os.path.basename(filename))
        newfile = newbase + ".tif"
        i = 0
        while os.path.isfile(newfile):
            i = i+1
            newfile = newbase+"_"+str(i)+".tif"

        progress = pguprogress.PGUProgressDialog( 'Import to '+newfile,
                                                  cancel = TRUE )
        progress.SetDefaultMessage( "translated" )

        old_cache_max = gdal.GetCacheMax()
        if old_cache_max < 20000000:
            gdal.SetCacheMax( 20000000 )
        
        new_dataset = geotiff.CreateCopy( newfile, dataset, FALSE,
                                          ['TILED=YES',],
                                          callback = progress.ProgressCB )
        dataset = None

        if progress.cancelled:
            progress.destroy()
            if os.path.isfile(newfile):
                os.unlink(newfile)
            gdal.SetCacheMax( old_cache_max );
            return
            
        if new_dataset == None:
            progress.destroy()
            gvutils.error('Unable to translate '+filename+' to '+newfile)
            if os.path.isfile(newfile):
                os.unlink(newfile)
            gdal.SetCacheMax( old_cache_max );
            return

        progress.SetDefaultMessage( "overviews built" )
        new_dataset.BuildOverviews( "average", callback = progress.ProgressCB )
        new_dataset = None

        progress.destroy()

        gdal.SetCacheMax( old_cache_max );

        # open normally
        self.file_open_by_name( newfile, sds_check=0 )


    def file_open_cb(self, *args):
        self.make_active()
        pgufilesel.SimpleFileSelect( self.file_open_name_check, None,
                                     'File Open',
                                     help_topic = 'files.html' )

# buffer function to check for wild cards in filename and then expand them
    def file_open_name_check(self, filename, lut=None,*args):
        if ('*' in filename)or('?' in filename):
            for file in glob.glob(filename):
               self.file_open_by_name(file)
        else:
            self.file_open_by_name(filename)

    def open_subdataset_check( self, dataset ):
        import gvsdsdlg
        dlg = gvsdsdlg.GvSDSDlg(dataset, self)

    def file_open_by_name(self, filename, lut=None, sds_check=1, *args):
        self.make_active()

        head=os.path.dirname(filename)
        pgufilesel.simple_file_sel_dir=head+os.sep

        if gvutils.is_shapefile(filename):
            self.file_open_shape_by_name(filename)
            return

        dataset = gview.manager.get_dataset(filename)
        if dataset is None and gdal.GetLastErrorNo() != 4:
            gvutils.error( 'Unable to open '+filename+'\n\n' \
                           + gdal.GetLastErrorMsg() )
            return

        if dataset is None and self.file_open_ogr_by_name(filename):
            return

        if dataset is None:
            gvutils.error('Unable to open '+filename+'\n\n' \
                          + gdal.GetLastErrorMsg() )
            return

        if sds_check and len(dataset.GetSubDatasets()) > 0:
            self.open_subdataset_check( dataset )
            return
        
        self.app.add_to_rfl(filename)

        raster = gview.manager.get_dataset_raster(dataset,1)
        options = []
        if gview.get_preference('gcp_warp_mode') is not None \
           and gview.get_preference('gcp_warp_mode') == 'no':
            options.append(('raw','yes'))

        if lut:
            raster_layer = gview.GvRasterLayer(raster, options,
                                           rl_mode = gview.RLM_SINGLE )
            #raster_layer.lut_color_wheel_1d_new(s=1.0, v=1.0, offset=0.0 )
            #print raster_layer.lut_get()

            raster_layer.lut_put(lut)

        elif dataset.RasterCount > 2:
            raster_layer = gview.GvRasterLayer(raster, options,
                                               rl_mode = gview.RLM_RGBA )
        else:
            raster_layer = gview.GvRasterLayer(raster, options,
                                               rl_mode = gview.RLM_AUTO )
        raster_layer.set_name(filename)

        # Lots of logic to handle RGB and RGBA Layers
        if raster_layer.get_mode() == gview.RLM_RGBA \
           and dataset.RasterCount > 2:
            
            green_raster = gview.manager.get_dataset_raster(dataset,2)
            blue_raster = gview.manager.get_dataset_raster(dataset,3)

            raster_layer.set_source(1,green_raster)
            raster_layer.set_source(2,blue_raster)

            if dataset.RasterCount > 3:
                band = dataset.GetRasterBand(4)
                if band.GetRasterColorInterpretation() == gdal.GCI_AlphaBand:
                    raster_layer.blend_mode_set( gview.RL_BLEND_FILTER )
                    alpha_raster = \
                        gview.manager.get_dataset_raster(dataset, 4) 
                    raster_layer.set_source(3,alpha_raster)

        self.viewarea.add_layer(raster_layer)
        self.viewarea.set_active_layer(raster_layer)
        self.rawgeo_update()

    def create_iconbar(self):
        self.iconbar = gtk.GtkToolbar(gtk.ORIENTATION_HORIZONTAL,
                                      gtk.TOOLBAR_ICONS)

        self.add_icon_to_bar( 'openfile.xpm', None,
                              'Open and Display Raster/Vector File',
                              self.file_open_cb )

        self.add_icon_to_bar( 'print.xpm', None,
                              'Print Current View',
                              self.print_cb, 'gvprint.html' )

        self.add_icon_to_bar( 'nonelut.xpm', None,
                              'Revert to no Enhancement',
                              self.nonelut_cb )

        self.add_icon_to_bar( 'equalize.xpm', None,
                              'Apply Equalization Enhancement to Raster',
                              self.equalize_cb )

        self.add_icon_to_bar( 'classify.xpm', None,
                              'Classify Raster',
                              self.classify_cb )

        self.add_icon_to_bar( 'legend.xpm', None,
                              'Show Legend',
                              self.show_legend_cb )

        self.add_icon_to_bar( 'seeall.xpm', None,
                              'Fit All Layers',
                              self.seeall_cb )

        # Zoom ratio selection box
        zoom_factor = gtk.GtkCombo()
        zoom_factor.set_popdown_strings(ratio_list)
        zoom_factor.entry.set_text('1:1')
        zoom_factor.set_usize(70,20)
        self.zoom_entry_changed_id = zoom_factor.entry.connect('changed', self.set_zoom_factor_cb)
        zoom_factor.list.connect('selection-changed', self.set_zoom_factor_focus_cb)
        self.zoom_factor = zoom_factor
        self.iconbar.append_widget(self.zoom_factor, 'Zoom Ratio', 'Zoom Ratio')

        self.add_icon_to_bar( 'zoomin.xpm', None,
                              'Zoom in x2',
                              self.zoomin_cb )

        self.add_icon_to_bar( 'zoomout.xpm', None,
                              'Zoom out x2',
                              self.zoomout_cb )

        self.add_icon_to_bar( 'refresh.xpm', None,
                              'Refresh Rasters From Disk',
                              self.refresh_cb )

        # raw / georeferenced pixmap
        self.raw_icon = gtk.create_pixmap_from_xpm(self,None,
                   os.path.join(gview.home_dir,'pics', 'worldg.xpm'))
        self.geo_icon = gtk.create_pixmap_from_xpm(self,None,
                   os.path.join(gview.home_dir,'pics', 'worldrgb.xpm'))
        self.rawgeo_pixmap = gtk.GtkPixmap(self.raw_icon[0],
                                             self.raw_icon[1])
        self.iconbar.append_item(None, 'Georeferenced',
                                 'Georeferenced', self.rawgeo_pixmap,
                                 self.rawgeo_cb )

        # Help
        self.add_icon_to_bar( 'help.xpm', None,
                              'Launch Online Help',
                              self.helpcb )

        # idle / busy pixmap
        self.idle_icon = gtk.create_pixmap_from_xpm(self,None,
                   os.path.join(gview.home_dir,'pics', 'idle.xpm'))
        self.busy_icon = gtk.create_pixmap_from_xpm(self,None,
                   os.path.join(gview.home_dir,'pics', 'busy.xpm'))
        self.idlebusy_pixmap = gtk.GtkPixmap(self.busy_icon[0],
                                             self.busy_icon[1])
        self.iconbar.append_item(None, 'Busy Indicator',
                                 'Busy Indicator', self.idlebusy_pixmap,
                                 self.do_nothing )

        gview.manager.set_busy(TRUE)
        gview.manager.connect('busy-changed', self.busy_changed_cb)

    def do_nothing(self, *args):
        pass
    
    def add_icon_to_bar(self, filename, text, hint_text, cb, help_topic=None):
        full_filename = os.path.join(gview.home_dir,'pics',filename)
        pix, mask = gtk.create_pixmap_from_xpm(self,None,full_filename)
        item = self.iconbar.append_item(text,hint_text, hint_text,
                                        gtk.GtkPixmap(pix,mask), cb )
        if help_topic is not None:
            gvhtml.set_help_topic(item, help_topic)

    def classify_cb(self, *args):
        self.make_active()
        try:
            self.viewarea.active_layer().classify()
        except:
            gvutils.warning('This can only be applied to a raster layer.\n' \
                          + 'Select a raster layer for this view in the \n' \
                          + 'layers dialog.' )
        
    def show_legend_cb(self, *args):
        self.make_active()
        try:
            self.viewarea.active_layer().show_legend()
        except:
            gvutils.warning( 'Legends are currently only available for rasters.' )
        
    def equalize_cb(self, *args):
        self.make_active()
        try:
            self.viewarea.active_layer().equalize()
        except:
            gvutils.warning('This can only be applied to a raster layer.\n' \
                          + 'Select a raster layer for this view in the \nlayers dialog.' )
        
    def nonelut_cb(self, *args):
        self.make_active()
        try:
            layer = self.viewarea.active_layer()
            if layer.get_mode() == gview.RLM_SINGLE:
                layer.lut_put(None)
                layer.set_source(0, layer.get_data(0),
                                 layer.min_get(0), layer.max_get(0),
                                 layer.get_const_value(0), None )
            elif layer.get_mode() == gview.RLM_RGBA:
                layer.lut_put(None)
                for isource in range(4):
                    layer.set_source(isource, layer.get_data(isource),
                                     layer.min_get(isource),
                                     layer.max_get(isource),
                                     layer.get_const_value(isource), None )
            else:
                gvutils.warning('This operation cannot be applied to\n'+\
                                'complex raster layers.' )
        except:
            gvutils.warning('This can only be applied to a raster layer.\n' \
                          + 'Select a raster layer for this view in the \nlayers dialog.' )

    def seeall_cb(self,*args):
        self.make_active()
        try:
            self.viewarea.fit_all_layers()
        except:
            pass
        
    def onetoone_cb(self,*args):
        self.make_active()
        try:
            view = self.viewarea
            layer = view.active_layer()
            point1 = view.inverse_map_pointer(layer.pixel_to_view( 0, 0 ))
            point2 = view.inverse_map_pointer(layer.pixel_to_view( 1, 1 ))
            dist = math.sqrt(math.pow((point1[0]-point2[0]),2)
                             + math.pow((point1[1]-point2[1]),2))
            factor = dist / math.sqrt(2)
            view.zoom(-1 * (math.log(factor) / math.log(2)) )
        except:
            gvutils.warning('This operation can only be done if a raster layer is the\nactive layer.  Please select a raster layer for this view in the layers dialog.')

    def set_zoom_factor_focus_cb(self,*args):
        """ Keep the focus in the view window when we selected a new zooming ratio from
        the combo box.  To ensure key events still recieved such as Home, and arrows """
        self.viewarea.grab_focus()
    
    def set_zoom_factor_cb(self,*args):
        self.make_active()
        try:
            ratio_text = string.split(self.zoom_factor.entry.get_text(), ':')
            ratio = [string.atof(ratio_text[0]), string.atof(ratio_text[1])]
        except:
            # if invalid text entered do nothing
            return

        # Make sure both values are positive
        if (ratio[0] <= 0.0) or (ratio[1] <= 0.0):
            return

        try:
            view = self.viewarea
            layer = view.active_layer()
            point1 = view.inverse_map_pointer(layer.pixel_to_view( 0, 0 ))
            point2 = view.inverse_map_pointer(layer.pixel_to_view( 1, 1 ))
            dist = math.sqrt(math.pow((point1[0]-point2[0]),2)
                             + math.pow((point1[1]-point2[1]),2))
            factor = dist / math.sqrt(2)
            self.zoom = factor
        
            # Block view-state-changed signal while we update zoom factor
            view.signal_handler_block(self.view_state_changed_id)
            view.zoom(-1 * (math.log((ratio[1]/ratio[0])*factor) / math.log(2)) )
            view.signal_handler_unblock(self.view_state_changed_id)

            self.zoom_flag = 'yes'
        except:
            # To prevent multiple error messages use the zoom_flag to keep track if we
            # have successfully zoomed since last error message, if not then we don't
            # generate another one
            if self.zoom_flag == 'yes':
                self.zoom_flag = 'no'
                gvutils.warning('This operation can only be done if a raster layer is the\nactive layer.  Please select a raster layer for this view\nin the layers dialog.')

        #self.viewarea.grab_focus()
          
    def refresh_cb(self, *args):
        self.make_active()
        try:
            layer = self.viewarea.active_layer()
            for isource in range(4):
                raster = layer.get_data(isource)
                if raster is not None:
                    raster.changed()
        except:
            gvutils.warning('The refresh from disk operation can only be\n'+\
                            'applied to raster layers.  Select a raster\n'+\
                            'layer for this view in the layers dialog.')
                            
            
            pass
        
    def zoomin_cb(self,*args):
        self.make_active()
        try:
            self.viewarea.zoom(1)
        except:
            pass
        
    def zoomout_cb(self,*args):
        self.make_active()
        try:
            self.viewarea.zoom(-1)
        except:
            pass

    def update_zoom_cb(self, *args):
        # Note: we do NOT use temp_zoom to get the zooming factor (doesn't work for
        #       geo-referenced images) we just use it as a way to check if the zoom
        #       has changed and therefore if we have to do the calculation
        temp_zoom = self.viewarea.get_zoom()
        layer = self.viewarea.active_layer()

        try:
            # Check if zoom factor changed
            if (temp_zoom != self.zoom) and (layer is not None):
                self.zoom = temp_zoom
                self.zoom_flag = 'yes'

                point1 = self.viewarea.inverse_map_pointer(layer.pixel_to_view( 0, 0 ))
                point2 = self.viewarea.inverse_map_pointer(layer.pixel_to_view( 1, 1 ))
                dist = math.sqrt(math.pow((point1[0]-point2[0]),2)
                                 + math.pow((point1[1]-point2[1]),2))
                factor = dist / math.sqrt(2)
            
                if (factor > 1):
                    ratio = str(round((factor/1.0),1)) + ':1'
                else:
                    ratio = '1:' + str(round(1.0/factor,1))

                # Block combo box changed signal while we update the text entry
                self.zoom_factor.entry.signal_handler_block(self.zoom_entry_changed_id)
                self.zoom_factor.entry.set_text(ratio)
                self.zoom_factor.entry.signal_handler_unblock(self.zoom_entry_changed_id)
        except:
            self.zoom_factor.entry.signal_handler_block(self.zoom_entry_changed_id)
            self.zoom_factor.entry.set_text('?:?')
            self.zoom_factor.entry.signal_handler_unblock(self.zoom_entry_changed_id)

        # Put focus back into view window
        #self.viewarea.grab_focus()

        # Return false to continue propogation of the view-state-changed signal
        return gtk.FALSE   

        
    def pyshell(self, *args):
        self.make_active()
        import pyshell
        shell = pyshell.Shell(inherit=1)
 
        # Initialization Commands
        shell.command('from Numeric import *')
        shell.command('from gdalnumeric import *')

        shell.show_all()
        
        
    # -------- 3D File Open and Setup --------

    def open_3D_request(self, *args):
        """ 3D File Open Dialog for selecting drape and height data """
        self.make_active()
        self.drape_dataset = None
        self.DEM_dataset = None

        # Create Dialog Window
        dialog = gtk.GtkWindow()
        dialog.set_title('Open 3D')
        dialog.set_border_width(10)
        dialog.set_usize(500, 700)
        dialog.set_policy(FALSE, FALSE, TRUE)
        gvhtml.set_help_topic( dialog, 'open3d.html' )
        
        box = gtk.GtkVBox(homogeneous=FALSE, spacing=10)
        dialog.add(box)
        self.file_dialog_3D = dialog
        
        # Drape File Selector
        drape_label = gtk.GtkLabel('Select Drape')
        box.pack_start(drape_label)

        self.drape_fileSelectWin = gtk.GtkFileSelection()
        zsChildren = self.drape_fileSelectWin.children()[0].children() 
        for zsChild in zsChildren : zsChild.reparent(box)

        # DEM File Selector
        ruler1 = gtk.GtkHSeparator()
        box.pack_start(ruler1)
        DEM_label = gtk.GtkLabel('Select DEM')
        box.pack_start(DEM_label)

        self.DEM_fileSelectWin = gtk.GtkFileSelection()
        zsChildren = self.DEM_fileSelectWin.children()[0].children() 
        for zsChild in zsChildren : zsChild.reparent(box)

        # Mesh LOD and Height Scale
        mesh_opts = gtk.GtkHBox(homogeneous=FALSE, spacing=10)
        lod_label =  gtk.GtkLabel('Mesh Level of Detail')
        spin_adjust = gtk.GtkAdjustment(value=3, lower=0, upper=8, step_incr=1)
        self.lod_spin_button = gtk.GtkSpinButton(spin_adjust, climb_rate=1, digits=0)

        hscale_label = gtk.GtkLabel('Height Scaling Factor:')
        self.scale_value = gtk.GtkEntry(maxlen=7)
        self.scale_value.set_text('1.0')
        
        mesh_opts.pack_start(lod_label)
        mesh_opts.pack_start(self.lod_spin_button)
        mesh_opts.pack_start(hscale_label)
        mesh_opts.pack_start(self.scale_value)
        box.pack_start(mesh_opts)

        # Okay/Cancel Buttons
        buttons = gtk.GtkHBox(homogeneous=FALSE, spacing=10)
        okay = gtk.GtkButton('OK')
        okay.set_usize(64, 32)
        okay.connect('clicked', self.perform_3D_request)
        
        cancel = gtk.GtkButton('Cancel')
        cancel.set_usize(64, 32)
        cancel.connect('clicked', dialog.destroy)

        help = gtk.GtkButton('Help')
        help.set_usize(64, 32)
        help.connect('clicked', self.helpcb, 'open3d.html')

        buttons.pack_end(help, expand=FALSE)
        buttons.pack_end(cancel, expand=FALSE)
        buttons.pack_end(okay, expand=FALSE)
        box.pack_start(buttons, expand=FALSE)

        # Show everything but unused fileselection buttons
        dialog.show_all()
        box.children()[1].hide()  # Remove Drape Create/Delete/Rename 
        box.children()[6].hide()  # Remove Drape Ok/Cancel
        box.children()[9].hide()  # Remove DEM Create/Delete
        box.children()[14].hide() # Remove DEM Ok/Cancel
        

    def perform_3D_request(self, *args):
        """Tries to open selected files, then creates 3D Layer and switches to 3D mode"""

        self.make_active()
        gview.manager.set_busy(TRUE)
        
        # Get Data
        drape_dataset = gview.manager.get_dataset(self.drape_fileSelectWin.get_filename())
        if drape_dataset is None or drape_dataset._o is None:
            gvutils.error( 'Unable to open drape dataset: '+\
                           self.drape_fileSelectWin.get_filename())
            return

        DEM_dataset = self.raster_open_by_name(self.DEM_fileSelectWin.get_filename())
        if DEM_dataset is None or DEM_dataset._o is None:
            return
            
        mesh_lod = self.lod_spin_button.get_value_as_int()
        hscale = float(self.scale_value.get_text())

        if (drape_dataset is not None) and (DEM_dataset is not None):
            # Get Current View & Prefs
            view = self.viewarea

            options = []
            if gview.get_preference('_gcp_warp_mode') is not None \
               and gview.get_preference('_gcp_warp_mode') == 'no':
                options.append(('raw','yes'))

            # Set Current View to 3D Mode
            view.set_mode(gvconst.MODE_3D)
            view.height_scale(hscale)
            options.append(('mesh_lod',str(mesh_lod)))

            band = drape_dataset.GetRasterBand(1)
            interp = band.GetRasterColorInterpretation()
            
            # Create Drape Raster
            drape_raster = gview.manager.get_dataset_raster(drape_dataset,1)
            gview.undo_register(drape_raster)

            # Create Drape Raster Layer
            drape_raster_layer = gview.GvRasterLayer(drape_raster, options,
                                                     rl_mode = gview.RLM_AUTO )

            # Logic to handle RGB and RGBA Layers
            if drape_raster_layer.get_mode() == gview.RLM_RGBA:
            
                green_raster= gview.manager.get_dataset_raster(drape_dataset,2)
                blue_raster = gview.manager.get_dataset_raster(drape_dataset,3)

                drape_raster_layer.set_source(1,green_raster)
                drape_raster_layer.set_source(2,blue_raster)

                if drape_dataset.RasterCount > 3:
                    band = drape_dataset.GetRasterBand(4)
                    if band.GetRasterColorInterpretation() == \
                                                gdal.GCI_AlphaBand:
                        drape_raster_layer.blend_mode_set(
                            gview.RL_BLEND_FILTER )
                        drape_raster_layer.set_source(3,
                             gview.manager.get_dataset_raster(drape_dataset,4))

            # Add to view
            view.add_layer(drape_raster_layer)
            view.set_active_layer(drape_raster_layer)

            # Create DEM Raster and Add as Height
            DEM_raster = gview.GvRaster(dataset=DEM_dataset)
            DEM_raster.set_name(str(self.DEM_fileSelectWin.get_filename()))
            drape_raster_layer.add_height(DEM_raster)

            # Clean up File Dialog Window
            self.file_dialog_3D.destroy()

    def position_3d(self, *args):
        self.make_active()
        if self.position3D_dialog is None:
            self.position3D_dialog = \
                         openev.Position_3D_Dialog(self.app.view_manager)
            self.position3D_dialog.connect('destroy', self.destroy_position_3d)
        self.position3D_dialog.show()
        self.position3D_dialog.get_window()._raise()

        view = self.viewarea
        self.position3D_dialog.update_cb(view)
        view.connect('view-state-changed', self.position3D_dialog.update_cb)

    def destroy_position_3d(self,*args):
        self.position3D_dialog = None
                
    def raster_open_by_name(self,filename):
        self.make_active()
        gdal.ErrorReset()
        dataset = gdal.Open(filename)
        if dataset is None:
            gvutils.error('Unable to open: '+filename+'\n\n'+ \
                          gdal.GetLastErrorMsg())
            return None
        
        return dataset

    def rawgeo_cb( self, *args ):
        ref_layer = self.viewarea.active_layer()
        self.viewarea.set_raw(ref_layer, not self.viewarea.get_raw(ref_layer))
        self.rawgeo_update()

    def rawgeo_update( self, *args ):
        ref_layer = self.viewarea.active_layer()
        if self.viewarea.get_raw( ref_layer ):
            self.rawgeo_pixmap.set( self.raw_icon[0], self.raw_icon[1] )
        else:
            self.rawgeo_pixmap.set( self.geo_icon[0], self.geo_icon[1] )
